---
title: "GDP Models"
author: "Brian Howard"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output: 
  html_document:
    toc: true
    toc_depth: 4
    smart: false
output_file: "GDPModels.html"
---

```{r setup, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options("getSymbols.warning4.0"=FALSE)
```

```{r libraries, echo=FALSE, message=FALSE}

library(tidyverse)
library(tidyquant)
library(Hmisc)
library(gridExtra)
library(signal)
library(caret)
library(data.table)

```

```{r helper functions, echo=FALSE}

# Call helper functions
source("plotHelper.r")
source("modelHelper.r")

```


```{r load.data, echo=FALSE}

str.data.dir <- "C:/Users/Rainy/OneDrive/Documents/IssaquahDynamical/Datasets/2529RS0082_HistEconData"
out.file <- file.path(str.data.dir, "RecessionIndicator_Buffer.RData")

# Load data
load(out.file)

rm(str.data.dir)
rm(out.file)

```


```{r plot.limits, echo=FALSE}

# Define the plotting ranges
dt.recent = as.Date("2017-01-01")

# Define the start of the prediction
dt.start.prediction <- as.Date("01/02/1962", "%d/%m/%Y")

# Back test range
dt_start_back_test = as.Date('1960-01-01')

# Define the S&P 500 limits
source("SetGSPCMax.r")

```


```{r clean_data, echo=FALSE}

# Keep only the symbols needed by this code
df.symbols <- dplyr::filter(df.symbols,
                            string.symbol %in% c("USREC",
                                                 "GDP",
                                                 "GDPC1",
                                                 "GDPNOW",
                                                 "PCE",
                                                 "GDPDEF",
                                                 "PCE",
                                                 "GSG",
                                                 "XLE",
                                                 "PKG",
                                                 "IP",
                                                 "UPS",
                                                 "FDX",
                                                 "^DJI",
                                                 "INDPRO",
                                                 "RRSFS",
                                                 "RSALES",
                                                 "ALTSALES",
                                                 "MSPUS",
                                                 "HOUST"))

if( exists("b.refresh.models")){
  rm(b.refresh.models)
}

if( exists("bRefresh")){
  rm(bRefresh)
}

if( exists("d.income")){
  rm(d.income)
}

if( exists("d.Russell.max")){
  rm(d.Russell.max)
}

if( exists("dt.date")){
  rm(dt.date)
}

if( exists("dt.date.c")){
  rm(dt.date.c)
}

if( exists("i.cols")){
  rm(i.cols)
}

if( exists("idx")){
  rm(idx)
}

if( exists("list.margin.names")){
  rm(list.margin.names)
}

if( exists("list.options.names")){
  rm(list.options.names)
}

if( exists("str.name")){
  rm(str.name)
}

if( exists("str.safe.name")){
  rm(str.safe.name)
}

if( exists("str.symbol")){
  rm(str.symbol)
}

if( exists("str.symbol.raw")){
  rm(str.symbol.raw)
}

if( exists("ylimBackTest")){
  rm(ylimBackTest)
}

```

# Open items
I also wonder what a deep stateful. LSTM is. That seems like a typo. Ohh they
use it twice so maybe it isn't. We might need to look at that. It might work
here, we will see.

# Feature Extraction

With the raw data downloaded, some of the interesting features can be extracted.
The first step is reconcile the time intervals. Some of the data is released
monthly and some daily. I chose to interpolate all data to a daily interval. The
first section of code adds the daily rows to the dataframe.

The code performs interpolation for continuous data or carries it forward for
binary data like the recession indicators.

```{r aggsyms}

source("utilSyms.r")
source("calcInterpolate.r")
df.data <- calcInterpolate(df.symbols)

# Truncate data
df.data <- df.data[as.Date(rownames(df.data)) > as.Date("1940-01-01"),]

```

# Create aggregate series

Some analysis requires that two or more series be combined. For example, normallizing debt by GDP to get a sense of the proportion of debt to the total economy helps understand the debt cycle.

```{r create aggregate, echo=FALSE}

source("calcAggregateSeries.r")

```

Year over year, smoothed derivative, and log trends tend to smooth out seasonal variation. It gets used so often that I do this for every series downloaded.

```{r calcsYoYSmoothLog}

source("calcFeatures.r")
lst.df <- calcFeatures(df.data, df.symbols)
df.data <- lst.df[[1]]
df.symbols <- lst.df[[2]]
```


```{r calc.features.for.aggregate, echo=FALSE}

# Calculate the features for the aggregated series
source("calcFeaturesAggregate.r")

```

# Recession Initiation (Switch Model)

Build the recession and recession initiation dates

```{r recframe}

source("calcRecession.r")

```

## GDP Models

### Validate GDP Series

I was confused about what was in the GDPNow series. I created this series of
plots to be sure nominal and real GDP were correct.

```{r validate_gdp_series, echo=FALSE, fig.width = 10, fig.asp = .62}

lst_sym <- c( "GDP.Value__YoY", "GDPC1.Value__YoY", "GDPNOW.Value")

if (require_columns(df.data, lst_sym)) {
  
  # Define common parameters for the 2 plots  
  ylim_gpd <- c(-10, 20)
  dt_start_gdp = as.Date('2000-01-01')
  
  # Create the nominal GDP series
  p1 <- plotSingleQuick(
    dfRecession, 
    df.data, 
    lst_sym[[1]], 
    ylim = ylim_gpd, 
    dt.start = dt_start_gdp, 
    b.percentile = FALSE)
  p1 <- p1 + geom_line(
    data = df.data,
    aes(
      x = .data[["date"]],
      y = .data[[lst_sym[[3]]]],
      colour = lst_sym[[3]]
    ),
    na.rm = TRUE
  )
  
  # Create the real GDP series
  p2 <- plotSingleQuick(
    dfRecession,
    df.data,
    lst_sym[[2]],
    ylim = ylim_gpd,
    dt.start = dt_start_gdp,
    b.percentile = FALSE,
    b.legend = TRUE
  )
  p2 <- p2 + geom_line(
    data = df.data,
    aes(
      x = .data[["date"]],
      y = .data[[lst_sym[[3]]]],
      colour = lst_sym[[3]]
    ),
    na.rm = TRUE
  )
  
  grid.arrange(p1,
               p2,
               ncol = 1,
               top = "Nominal and real GDP")

  
  # Clean and tidy memory
  if( exists ("p1")){
    rm(p1)
  }
  if( exists ("p2")){
    rm(p2)
  }  
  if( exists ("ylim_gpd")){
    rm(ylim_gpd)
  }  
  
}

# Clean and tidy
if( exists ("lst_sym")){
  rm(lst_sym)
}

```


```{r validate_gdp_series_yoy, echo=FALSE, fig.width = 10, fig.asp = .62}

datay <- "GDPC1.Value__YoY"
datay.aux.1 <- "GDP__by__GDPDEF__YoY"
ylim <- c(-10, 20)
dtStart = as.Date('2000-01-01')
p1 <-
  plotSingleQuick(dfRecession, df.data, datay, ylim, dtStart, b.legend <- TRUE, b.percentile = FALSE)
p1 + geom_line(
    data = df.data,
    aes_string(x = "date",
      y = datay.aux.1,
      colour = shQuote(datay.aux.1)
    ),
    na.rm = TRUE
  )

```

```{r define_ranges, echo=FALSE, fig.width = 10, fig.asp = .62}

# Define training ranges and parameters

# Exclude the Covid19 data sets
dt.start.prediction <- as.Date(max(c(index(CLF16OV[1]), index(POPTHM[1]))))
dt.end.prediction <- as.Date("2020-01-31")

```

# Supporting Series Models

The underlying data series for GDP only get updated once a month and they are
often delayed by weeks. I would like to synthesize a few series that could be
used to get more up to date estimates. I am going to start with the PCE series
since that is the largest contributor to the GDP numbers.

## PCE

### Data exploration

Truncate the data. Yahoo rarely goes past 2000

```{r pce_data_exp, echo=FALSE, fig.width = 10, fig.asp = .62}

dt.start.prediction.pce <- as.Date("2000-01-01")
df.data.pce <- df.data[as.Date(rownames(df.data)) > dt.start.prediction.pce,]

```

Starting with some correlation see if we can find market data series (updated
daily) that could be used to estimate PCE.

```{r pce_data_exp_corr, echo=FALSE, fig.width = 10, fig.asp = .62}

training.cor.pce <-
  df.data.pce[, c("PCE.Value", "GSG.Close", "XLE.Close", "PKG.Close", "IP.Close", "UPS.Close", "FDX.Close", "X_DJI.DJI.Open")]

  rcorr.data <- rcorr(as.matrix(training.cor.pce), type = "pearson")
  #print(rcorr.data)

  corrplot::corrplot(cor(training.cor.pce), type="upper", order="original", 
           tl.col="black", tl.srt=45, title ="GDP Data")

```

### Begin training up some models for PCE

```{r pce_model_dates, echo=FALSE, fig.width = 10, fig.asp = .62}

df.pce.model <-
  df.data[df.data$date >= dt.start.prediction.pce &
            df.data$date <= dt.end.prediction,]

```

#### I break the data into three sets: 50% for training, 25% for testing, and 25% for validation.

```{r pce_model_partition, echo=FALSE, fig.width = 10, fig.asp = .62}

set.seed(123456)
in.train <- createDataPartition(y = df.pce.model$PCE.Value, p = 0.50, list = FALSE)
df.train <- df.pce.model[in.train,]
df.data.rest <- df.pce.model[-in.train,]
in.val <- createDataPartition(y = df.data.rest$PCE.Value, p = 0.50, list = FALSE)
df.val <- df.data.rest[in.val,]
df.test <- df.data.rest[-in.val,]
rm(df.data.rest)

```

#### Perform the linear fit

```{r pce_model_fit_linear, echo=FALSE, fig.width = 10, fig.asp = .62}

list.fit.reg.pce <- train(
  PCE.Value ~ GSG.Close + PKG.Close + UPS.Close + FDX.Close,
  data = df.train,
  method = "lm",
  preProcess = c('center', 'scale')
)

```

#### Perform the pca fit

```{r pce_model_fit_pca, echo=FALSE, fig.width = 10, fig.asp = .62}

list.fit.pcr.pce <- train(
  PCE.Value ~ GSG.Close + PKG.Close + UPS.Close + FDX.Close + X_DJI.DJI.Open,
  data = df.train,
  method = "pcr",
  preProcess = c('center', 'scale')
)

```

#### Perform the knn fit

```{r pce_model_fit_knn, echo=FALSE, fig.width = 10, fig.asp = .62}

list.fit.knn.pce <- train(
  PCE.Value ~ GSG.Close + PKG.Close + UPS.Close + FDX.Close + X_DJI.DJI.Open,
  data = df.train,
  method = "knn",
  preProcess = c('center', 'scale')
)

```

### Adds the linear prediction to the data frame

#### Make the prediction

```{r pce_model_sym_def, echo=FALSE, fig.width = 10, fig.asp = .62}

# Add linear prediction to the data frame
str.symbol <- "PCE.lm"
df.data[str.symbol] <-
  predict(list.fit.reg.pce, newdata = df.data)

```


```{r pce_model_sym_add, echo=FALSE, fig.width = 10, fig.asp = .62}

# Define the new description
str.description <- "Linear Model Prediction\nPCE given GSG,\nPKG, UPS, and FDX"

# Update the symbols table    
df.symbols <- symbols_append_row(
    df.symbols,
    list(
      string.symbol = str.symbol,
      string.source = "Predict",
      string.description = str.description,
      string.label.y = getPlotYLabel(df.symbols, "PCE")[1],
      float.expense.ratio = -1.00,
      Max030 = FALSE,
      Max180 = FALSE,
      date.series.start = dt.start.prediction,
      date.series.end = as.Date(Sys.Date()),
      string.symbol_safe = safe_symbol_name(str.symbol),
      string.object_name = safe_symbol_name(str.symbol)
    )
)

```

#### Create the year-over-year values

Add the linear prediction year-over-year growth

```{r pce_model_sym_yoy, echo=FALSE, fig.width = 10, fig.asp = .62}

# The year-over-year calculation for the linear model
str.symbolYoY <- paste(str.symbol, "__YoY", sep = "")
df.data[str.symbolYoY] <- CalcYoY(df.data, str.symbol, 365)

# Should be done with this
if ( exists("str.symbol")){
  rm(str.symbol)
}

# Update the symbols table    
df.symbols <- symbols_append_row(
    df.symbols,
    list(
      string.symbol = str.symbolYoY,
      string.source = "Calc",
      string.description = paste(str.description, "\nYear over Year", sep =
                                   ""),
      string.label.y = "Percent",
      float.expense.ratio = -1.00,
      Max030 = FALSE,
      Max180 = FALSE,
      date.series.start = dt.start.prediction,
      date.series.end = as.Date(Sys.Date()),
      string.symbol_safe = safe_symbol_name(str.symbolYoY),
      string.object_name = safe_symbol_name(str.symbolYoY)
  )
)

```


### Add linear prediction by PCA to the dataframe

```{r pce_model_sym_def_pca, echo=FALSE, fig.width = 10, fig.asp = .62}

str.symbol.pcr <- "PCE.pcr"
df.data[str.symbol.pcr] <-
  predict(list.fit.pcr.pce, newdata = df.data, ncomp = 1)

```

Describe the model

```{r pce_model_sym_def_pca_desc, echo=FALSE, fig.width = 10, fig.asp = .62}

list.fit.pcr.pce


```

```{r pce_model_sym_add_pca, echo=FALSE, fig.width = 10, fig.asp = .62}

# Add the linear model prediction to the symbols table
str.description.pcr <- "PCE Regression Prediction\nPCE given GSG,\nPKG, UPS, and FDX"
df.symbols <- symbols_append_row(
    df.symbols,
    list(
      string.symbol = str.symbol.pcr,
      string.source = "Predict",
      string.description = str.description.pcr,
      string.label.y = getPlotYLabel(df.symbols, "PCE")[1],
      float.expense.ratio = -1.00,
      Max030 = FALSE,
      Max180 = FALSE,
      date.series.start = dt.start.prediction,
      date.series.end = as.Date(Sys.Date()),
      string.symbol_safe = safe_symbol_name(str.symbol.pcr),
      string.object_name = safe_symbol_name(str.symbol.pcr)
  )
)

```


### Add KNN prediction to the dataframe

```{r pce_model_sym_def_knn, echo=FALSE, fig.width = 10, fig.asp = .62}

str.symbol.pcr <- "PCE.knn"
df.data[str.symbol.pcr] <-
  predict(list.fit.pcr.pce, newdata = df.data, ncomp = 1)

```

```{r pce_model_sym_def_knn_desc, echo=FALSE, fig.width = 10, fig.asp = .62}

list.fit.knn.pce

```
Add the linear model prediction to the symbols table

```{r pce_model_sym_add_knn, echo=FALSE, fig.width = 10, fig.asp = .62}

str.description.pcr <- "KNN Prediction\nPCE given GSG,\nPKG, UPS, and FDX"
df.symbols <- symbols_append_row(
    df.symbols,
    list(
      string.symbol = str.symbol.pcr,
      string.source = "Predict",
      string.description = str.description.pcr,
      string.label.y = getPlotYLabel(df.symbols, "PCE")[1],
      float.expense.ratio = -1.00,
      Max030 = FALSE,
      Max180 = FALSE,
      date.series.start = dt.start.prediction,
      date.series.end = as.Date(Sys.Date()),
      string.symbol_safe = safe_symbol_name(str.symbol.pcr),
      string.object_name = safe_symbol_name(str.symbol.pcr)
  )
)

```

#### Add the PCA prediction year-over-year growth


```{r pce_model_sym_knn_yoy, echo=FALSE, fig.width = 10, fig.asp = .62}

# The YoY calculation
str.symbolYoY <- paste(str.symbol.pcr, "_YoY", sep = "")
df.data[str.symbolYoY] <- CalcYoY(df.data, str.symbol.pcr, 365)

df.symbols <- symbols_append_row(
    df.symbols,
    list(
      string.symbol = str.symbolYoY,
      string.source = "Calc",
      string.description = paste(str.description.pcr, "\nYear over Year", sep =
                                   ""),
      string.label.y = "Percent",
      float.expense.ratio = -1.00,
      Max030 = FALSE,
      Max180 = FALSE,
      date.series.start = dt.start.prediction,
      date.series.end = as.Date(Sys.Date()),
      string.symbol_safe = safe_symbol_name(str.symbolYoY),
      string.object_name = safe_symbol_name(str.symbolYoY)
  )
)

```


#### create PCE plot

```{r pce_model_plot, echo=FALSE, fig.width = 10, fig.asp = .62}

datay <- "PCE.Value"
datay.aux <- "PCE.lm"
datay.aux.1 <- "PCE.pcr"
datay.aux.2 <- "PCE.knn"
ylim <- c(1000, 20000)
dt.end <- Sys.Date()
myPlot <- 
  plotSingle(
    dfRecession,
    df.data,
    "date",
    datay,
    "PCE Compared to PCE predicted using linear model",
    "Date",
    getPlotYLabel(df.symbols, datay),
    c(dt.start.prediction.pce, dt.end),
    ylim,
    b.legend = TRUE,
    b.percentile = FALSE,
    b.long.legend = TRUE
  )
myPlot <- myPlot + geom_line(
  data = df.data,
  aes_string(
    x = "date",
    y = datay.aux,
    colour = shQuote(getPlotTitle(df.symbols, datay.aux)[[1]])
  ),
  na.rm = TRUE
)
myPlot <- myPlot + geom_line(
  data = df.data,
  aes_string(
    x = "date",
    y = datay.aux.1,
    colour = shQuote(getPlotTitle(df.symbols, datay.aux.1))
  ),
  na.rm = TRUE
)
myPlot <- myPlot + geom_line(
  data = df.data,
  aes_string(
    x = "date",
    y = datay.aux.2,
    colour = shQuote(getPlotTitle(df.symbols, datay.aux.2))
  ),
  na.rm = TRUE
)


print(myPlot)

```


## GDP Models

### Regression, Retail sales

See if we can get there with a simple regression model. Begin by taking a look
at how these data points correlate

```{r gdp_corr_plot, echo=FALSE, fig.width = 10, fig.asp = .62}

training.cor <-
  df.data[, c("GDP.Value", "INDPRO.Value", "PCE.Value", "RSALESAGG", "ALTSALES.Value", "MSPUS__times__HOUST")]

  rcorr.data <- rcorr(as.matrix(training.cor), type = "pearson")
  #print(rcorr.data)

  corrplot::corrplot(cor(training.cor), type="upper", order="original", 
           tl.col="black", tl.srt=45, title ="GDP Data")

```


### Begin training up some models for GDP


```{r gdp_define_dates, echo=FALSE, fig.width = 10, fig.asp = .62}

dt_start_prediction_gdp <- as.Date("1976-01-01")

df.gdp.model <-
  df.data[df.data$date >= dt_start_prediction_gdp &
            df.data$date <= dt.end.prediction,]

```

#### Partition data for GDP models

I break the data into three sets: 50% for training, 25% for testing, and 25% for validation.

```{r gdp_partition_data, echo=FALSE, fig.width = 10, fig.asp = .62}

set.seed(123456)
in.train <- createDataPartition(y=df.gdp.model$GDP.Value, p = 0.50, list=FALSE)
df.train <- df.gdp.model[in.train,]
df.data.rest <- df.gdp.model[-in.train,]
in.val <- createDataPartition(y = df.data.rest$GDP.Value, p = 0.50, list = FALSE)
df.val <- df.data.rest[in.val,]
df.test <- df.data.rest[-in.val,]
rm(df.data.rest)

```

#### Perform the linear fit

```{r gdp_fit_lm, echo=FALSE, fig.width = 10, fig.asp = .62}

lst_syms <- c("GDP.Value", 
              "INDPRO.Value",
              "PCE.Value",
              "RSALESAGG",
              "ALTSALES.Value",
              "MSPUS__times__HOUST")

if ( require_columns(df.data, lst_syms ) ){

  # Define the equation
  str_form <- as.formula(paste(lst_syms[[1]], "~", 
                               lst_syms[[2]], " + ",
                               lst_syms[[3]], " + ",
                               lst_syms[[4]], " + ",
                               lst_syms[[5]], " + ",
                               lst_syms[[6]]))
  
  list.fit.reg <- train(
    str_form,
    data = df.train,
    method = "lm",
    preProcess = c('center', 'scale')
  )

  # Call the function to create the fit description
  res <- extract_lm_weights(list.fit.reg)
  res$table
  
  if( exists("res")){
    rm(res)
  }

}


```

#### Perform the principal component regression (PCR) fit

PCR, or Principal Component Regression, is a two-stage regression technique used
to handle multicollinearity and high-dimensional data in model training.

```{r gdp_fit_pcr, echo=FALSE, fig.width = 10, fig.asp = .62}

if ( require_columns(df.data, lst_syms ) ){

  if( exists("str_form")){
    
    list.fit.pcr <- train(
      str_form,
      data = df.train,
      method = "pcr",
      preProcess = c('center', 'scale')
    )
    
    list.fit.pcr  
  }
}  

```


#### Perform PLS Fit
If you find that PCR loses predictive power because it ignores the target variable during dimensionality reduction, switch to PLS, which optimizes components to maximize covariance between X and y.

```{r gdp_fit_pls, echo=FALSE, fig.width = 10, fig.asp = .62}

if ( require_columns(df.data, lst_syms ) ){

  if( exists("str_form")){
    
    list.fit.pls <- train(
      str_form,
      data = df.train,
      method = "pls",
      preProcess = c('center', 'scale')
    )
    
    list.fit.pls
  }
}  

# Clean and tidy
if( exists("lst_syms")){
  rm(lst_syms)
}
if( exists("str_form")){
  rm(str_form)
}

```

### Adds the linear prediction to the data frame

Add the nominal linear prediction year-over-year growth

#### Add linear prediction to the dataframe

```{r gdp_fit_ln_add, echo=FALSE, fig.width = 10, fig.asp = .62}

str.symbol <- "GDP.lm"
df.data[str.symbol] <-
  predict(list.fit.reg, newdata = df.data)

# Add the linear model prediction to the symbols table
str.description <- "Linear Model Prediction\nGDP given INDPRO,\nPCE, RSALESAGG, ALTSALES,\nand housing"

df.symbols <- symbols_append_row(
    df.symbols,
    list(
      string.symbol = str.symbol,
      string.source = "Predict",
      string.description = str.description,
      string.label.y = getPlotYLabel(df.symbols, "POPTHM")[1],
      float.expense.ratio = -1.00,
      Max030 = FALSE,
      Max180 = FALSE,
      date.series.start = dt_start_prediction_gdp,
      date.series.end = as.Date(Sys.Date()),
      string.symbol_safe = safe_symbol_name(str.symbol),
      string.object_name = safe_symbol_name(str.symbol)
  )
)

```

#### Make the year over year calculation

```{r gdp_fit_lm_norm_yoy_calc, echo=FALSE, fig.width = 10, fig.asp = .62}

str.symbolYoY <- paste(str.symbol, "_YoY", sep = "")
df.data[str.symbolYoY] <- CalcYoY(df.data, str.symbol, 365)

df.symbols <- symbols_append_row(
    df.symbols,
    list(
      string.symbol = str.symbolYoY,
      string.source = "Calc",
      string.description = paste(str.description, "\nYear over Year", sep =
                                   ""),
      string.label.y = "Percent",
      float.expense.ratio = -1.00,
      Max030 = FALSE,
      Max180 = FALSE,
      date.series.start = dt_start_prediction_gdp,
      date.series.end = as.Date(Sys.Date()),
      string.symbol_safe = safe_symbol_name(str.symbolYoY),
      string.object_name = safe_symbol_name(str.symbolYoY)
  )
)

# Clean and tidy memory  
if( exists("str.symbolYoY")){
  rm(str.symbolYoY)
}
 
if( exists("str.symbol")){
  rm(str.symbol)
}

```

#### Normalize linear model GDP commodities by GDP deflator

```{r gdp_fit_ln_norm_def, echo=FALSE, fig.width = 10, fig.asp = .62}

str.symbol <- "GDP.lm.by.GDPDEF" 
df.data[str.symbol] <-
  (df.data$GDP.lm / df.data$GDPDEF.Value)

df.symbols <- symbols_append_row(
    df.symbols,
    list(
      string.symbol = "GDP.lm.by.GDPDEF",
      string.source = "Calc",
      string.description = "Linear Model Est. GDP \nNormalized by GDP def",
      string.label.y = "(-)",
      float.expense.ratio = -1.00,
      Max030 = FALSE,
      Max180 = FALSE,
      date.series.start =  as.Date(max(c(
        index(GDP[1]), index(GDPDEF[1])
      ))) ,
      date.series.end = as.Date(min(c(
        index(tail(GDP, 1)), index(tail(GDPDEF, 1))
      ))),
      string.symbol_safe = safe_symbol_name(str.symbol),
      string.object_name = safe_symbol_name(str.symbol)
  )
)

```


Add the real linear prediction (nominal/deflator) year-over-year growth

```{r gdp_fit_ln_norm_lm_def, echo=FALSE, fig.width = 10, fig.asp = .62}

str.symbol <- "GDP.lm.by.GDPDEF"
str.symbolYoY <- paste(str.symbol, "_YoY", sep = "")
df.data[str.symbolYoY] <- CalcYoY(df.data, str.symbol, 365)

df.symbols <- symbols_append_row(
    df.symbols,
    list(
      string.symbol = str.symbolYoY,
      string.source = "Calc",
      string.description = paste(str.description, "\nYear over Year", sep =
                                   ""),
      string.label.y = "Percent",
      float.expense.ratio = -1.00,
      Max030 = FALSE,
      Max180 = FALSE,
      date.series.start = dt.start.prediction,
      date.series.end = as.Date(Sys.Date()),
      string.symbol_safe = safe_symbol_name(str.symbolYoY),
      string.object_name = safe_symbol_name(str.symbolYoY)
  )
)

```

### Add linear prediction by PCA to the dataframe

Add the PCA to the main data frame

```{r gdp_pred_pcr_calc, echo=FALSE, fig.width = 10, fig.asp = .62}

str.symbol.pcr <- "GDP.pcr"
df.data[str.symbol.pcr] <-
  predict(list.fit.pcr, newdata = df.data, ncomp = 1)


```


#### Add the PCR model prediction to the symbols table

```{r gdp_pred_add_to_syms, echo=FALSE, fig.width = 10, fig.asp = .62}

str.description.pcr <- "PCA regression\nGDP given INDPRO,\nPCE, RSALESAGG, ALTSALES,\nand housing"  

df.symbols <- symbols_append_row(
    df.symbols,
    list(
      string.symbol = str.symbol.pcr,
      string.source = "Predict",
      string.description = str.description.pcr,
      string.label.y = getPlotYLabel(df.symbols, "PCE")[1],
      float.expense.ratio = -1.00,
      Max030 = FALSE,
      Max180 = FALSE,
      date.series.start = dt_start_prediction_gdp,
      date.series.end = as.Date(Sys.Date())
  )
)

```

Add the PCR prediction year-over-year growth

```{r gdp_pred_pcr_yoy, echo=FALSE, fig.width = 10, fig.asp = .62}

# The YoY calculation for PCA
str.symbolYoY <- paste(str.symbol.pcr, "_YoY", sep = "")
df.data[str.symbolYoY] <- CalcYoY(df.data, str.symbol.pcr, 365)

df.symbols <- symbols_append_row(
    df.symbols,
    list(
      string.symbol = str.symbolYoY,
      string.source = "Calc",
      string.description = paste(str.description.pcr, "\nYear over Year", sep =
                                   ""),
      string.label.y = "Percent",
      float.expense.ratio = -1.00,
      Max030 = FALSE,
      Max180 = FALSE,
      date.series.start = dt_start_prediction_gdp,
      date.series.end = as.Date(Sys.Date())
  )
)

# Clean and tidy memory  
if( exists("str.description.pcr")){
  rm(str.description.pcr)
}
```


### Add PLS prediction to the dataframe

Add the PLS to the main data frame

```{r gdp_pred_pls_calc, echo=FALSE, fig.width = 10, fig.asp = .62}

str.symbol.pls <- "GDP.pls"
df.data[str.symbol.pls] <-
  predict(list.fit.pls, newdata = df.data, ncomp = 1)

```


#### Add the PLS model prediction to the symbols table

```{r gdp_pred_add_pls_to_syms, echo=FALSE, fig.width = 10, fig.asp = .62}

str.description.pls <- "PLS regression\nGDP given INDPRO,\nPCE, RSALESAGG, ALTSALES,\nand housing"  

df.symbols <- symbols_append_row(
    df.symbols,
    list(
      string.symbol = str.symbol.pls,
      string.source = "Predict",
      string.description = str.description.pls,
      string.label.y = getPlotYLabel(df.symbols, "PCE")[1],
      float.expense.ratio = -1.00,
      Max030 = FALSE,
      Max180 = FALSE,
      date.series.start = dt_start_prediction_gdp,
      date.series.end = as.Date(Sys.Date())
  )
)

```

Add the PLS prediction year-over-year growth

```{r gdp_pred_pls_yoy, echo=FALSE, fig.width = 10, fig.asp = .62}

# The YoY calculation for PLS
str.symbolYoY <- paste(str.symbol.pls, "_YoY", sep = "")
df.data[str.symbolYoY] <- CalcYoY(df.data, str.symbol.pls, 365)

df.symbols <- symbols_append_row(
    df.symbols,
    list(
      string.symbol = str.symbolYoY,
      string.source = "Calc",
      string.description = paste(str.description.pls, "\nYear over Year", sep =
                                   ""),
      string.label.y = "Percent",
      float.expense.ratio = -1.00,
      Max030 = FALSE,
      Max180 = FALSE,
      date.series.start = dt_start_prediction_gdp,
      date.series.end = as.Date(Sys.Date())
  )
)

# Clean and tidy memory  
if( exists("str.description.pcr")){
  rm(str.description.pcr)
}
```

#### Plot GDP predictions



```{r gdp_pred_plot_fun, echo=FALSE, fig.width = 10, fig.asp = .62} 

#' Plot GDP and Model Predictions
#'
#' This function generates a time series plot comparing actual GDP to its 
#' predicted values from linear, PCR, and PLS regression models.
#'
#' @param df.data A data frame containing GDP and model prediction variables.
#' @param df.symbols A data frame or list used to resolve plot titles and labels.
#' @param dfRecession A data frame used for shading recession periods in the plot.
#' @param dt.start The start date of the plotted range (as Date).
#' @param y_lim_lower define the lower y limit valve (upper is determined from the data).
#'
#' @return A ggplot object showing GDP and model comparisons.
#' @examples
#' \dontrun{
#' plot_gdp_predictions(
#'   df.data = df.data,
#'   df.symbols = df.symbols,
#'   dfRecession = dfRecession,
#'   dt.start = as.Date("2015-01-01"),
#'   ylim = c(10000, 25000)
#' )
#' }
#' @export
#'
#' @author Brian Howard
#' @date 2025-10-05
plot_gdp_predictions <- function(df.data,
                                 df.symbols,
                                 dfRecession,
                                 dt.start = as.Date("2015-01-01"),
                                 y_lim_lower = 10000) {

  # Define series to plot
  lst_syms <- c("GDP.Value", "GDP.lm", "GDP.pcr", "GDP.pls")

  # Ensure required columns exist
  if (!require_columns(df.data, lst_syms)) {
    warning("Required GDP columns are missing from df.data.")
    return(invisible(NULL))
  }

  # Define date range
  dt.end <- Sys.Date()
  
  # Define the limits
  ylim_plot = c(y_lim_lower,  round_up_to(max(df.data[[lst_syms[[1]]]]),1))

  # Create base plot using the first series
  myPlot <- plotSingle(
    dfRecession,
    df.data,
    "date",
    datay = lst_syms[[1]],
    "GDP Compared to GDP predicted values",
    "Date",
    getPlotYLabel(df.symbols, lst_syms[[1]]),
    c(dt.start, dt.end),
    ylim = ylim_plot,
    b.legend = TRUE,
    b.percentile = FALSE,
    b.long.legend = TRUE
  )

  # Add lines for each modeled GDP series
  myPlot <- myPlot + geom_line(
    data = df.data,
    aes(
      x = .data[["date"]],
      y = .data[[lst_syms[[2]]]],
      colour = getPlotTitle(df.symbols, lst_syms[[2]])
    ),
    na.rm = TRUE
  )
  myPlot <- myPlot + geom_line(
    data = df.data,
    aes(
      x = .data[["date"]],
      y = .data[[lst_syms[[3]]]],
      colour = getPlotTitle(df.symbols, lst_syms[[3]])
    ),
    na.rm = TRUE
  )
  myPlot <- myPlot + geom_line(
    data = df.data,
    aes(
      x = .data[["date"]],
      y = .data[[lst_syms[[4]]]],
      colour = getPlotTitle(df.symbols, lst_syms[[4]])
    ),
    na.rm = TRUE
  )  

  # Display the plot
  print(myPlot)

  # Return the plot object for reuse or saving
  invisible(myPlot)
}


```


Plot out the results across the entire range of fit.

```{r gdp_pred_plot_long, echo=FALSE, fig.width = 10, fig.asp = .62}

plot_gdp_predictions(
   df.data = df.data,
   df.symbols = df.symbols,
   dfRecession = dfRecession,
   dt.start = dt_start_prediction_gdp,
   y_lim_lower = 0
)

```
  
  
Looking at some more recent data points

```{r gdp_pred_plot_near, echo=FALSE, fig.width = 10, fig.asp = .62}

plot_gdp_predictions(
   df.data = df.data,
   df.symbols = df.symbols,
   dfRecession = dfRecession,
   dt.start = as.Date("2015-01-01"),
   y_lim_lower = 10000
)

```  


```{r gdp_pred_plot_long_yoy_fun, echo=FALSE, fig.width = 10, fig.asp = .62} 

#' Plot Nominal and Real GDP Against Model Predictions
#'
#' This function generates two vertically stacked ggplot2 plots comparing actual GDP 
#' and related model predictions over a specified date range. The top plot shows 
#' year-over-year GDP versus its linear model and PCR-predicted values. 
#' The bottom plot compares GDPNOW and a linear model based on GDP deflator.
#'
#' @param df.data A data frame containing the GDP and model prediction series.
#' @param df.symbols A data frame or list used to resolve display titles and labels 
#'        for plotted variables.
#' @param dfRecession A data frame with recession period shading, passed to `plotSingle()`.
#' @param dt.start The start date for the plotted time range (as Date).
#' @param ylim.both A numeric vector of length 2 specifying y-axis limits for both
#         plots.
#'
#' @return A combined grid of two ggplot objects arranged vertically.
#' @examples
#' \dontrun{
#' plot_gdp_models(
#'   df.data = df.data,
#'   df.symbols = df.symbols,
#'   dfRecession = dfRecession,
#'   dt.start = as.Date("2015-01-01"),
#'   ylim.both = c(-25, 25)
#' )
#' }
#' @export
#'
#' @author Brian Howard
#' @date 2025-10-05
plot_gdp_models <- function(df.data,
                            df.symbols,
                            dfRecession,
                            dt.start = as.Date("2015-01-01"),
                            ylim.both = c(-25, 25)) {
  dt.end <- Sys.Date()

  #----------------------------#
  #   Top Plot: GDP YoY Models
  #----------------------------#
  lst_syms <- c("GDP.Value__YoY", "GDP.lm_YoY", "GDP.pcr_YoY")

  if (require_columns(df.data, lst_syms)) {
    p1 <- plotSingle(
      dfRecession,
      df.data,
      "date",
      datay = lst_syms[[1]],
      "GDP Compared to GDP predicted using linear model",
      "Date",
      getPlotYLabel(df.symbols, lst_syms[[1]]),
      c(dt.start, dt.end),
      ylim = ylim.both,
      b.legend = TRUE,
      b.percentile = FALSE,
      b.long.legend = TRUE
    )

    p1 <- p1 +
      geom_line(
        data = df.data,
        aes(
          x = .data[["date"]],
          y = .data[[lst_syms[[2]]]],
          colour = getPlotTitle(df.symbols, lst_syms[[2]])
        ),
        na.rm = TRUE
      ) +
      geom_line(
        data = df.data,
        aes(
          x = .data[["date"]],
          y = .data[[lst_syms[[3]]]],
          colour = getPlotTitle(df.symbols, lst_syms[[3]])
        ),
        na.rm = TRUE
      )
  }

  #----------------------------------------#
  #   Bottom Plot: GDPNOW vs Deflator Model
  #----------------------------------------#
  lst_syms_bottom <- c("GDPNOW.Value", "GDP.lm.by.GDPDEF_YoY")

  if (require_columns(df.data, lst_syms_bottom)) {
    p2 <- plotSingle(
      dfRecession,
      df.data,
      "date",
      datay = lst_syms_bottom[[1]],
      "GDP Compared to GDP predicted using linear model",
      "Date",
      getPlotYLabel(df.symbols, lst_syms_bottom[[1]]),
      c(dt.start, dt.end),
      ylim = ylim.both,
      b.legend = TRUE,
      b.percentile = FALSE,
      b.long.legend = TRUE
    )

    p2 <- p2 +
      geom_line(
        data = df.data,
        aes(
          x = .data[["date"]],
          y = .data[[lst_syms_bottom[[2]]]],
          colour = getPlotTitle(df.symbols, lst_syms_bottom[[2]])
        ),
        na.rm = TRUE
      )
  }

  #----------------------------#
  #   Combine and Return Plots
  #----------------------------#
  if (exists("p1") && exists("p2")) {
    grid.arrange(p1, p2, ncol = 1, top = "Nominal and Real GDP")
  } else if (exists("p1")) {
    print(p1)
  } else if (exists("p2")) {
    print(p2)
  } else {
    warning("Neither plot could be created — required columns missing.")
  }
}

```

This plot exists to show how the regression performs over the full range of data
considered in the fit.

```{r gdp_pred_plot_long_yoy, echo=FALSE, fig.width = 10, fig.asp = .62}

# Define the date range for both plots
dt_start_plot <- dt_start_prediction_gdp

# Call the function that creates the plot
plot_gdp_models(
   df.data = df.data,
   df.symbols = df.symbols,
   dfRecession = dfRecession,
   dt.start = dt_start_plot,
   ylim.both = c(-20, 20)
)

if( exists("dt_start_plot")){
  rm(dt_start_plot)
}

```

Take a look at the data over the last year

```{r gdp_pred_plot_short_yoy, echo=FALSE, fig.width = 10, fig.asp = .62}

# Define the date range for both plots
dt_start_plot <- Sys.Date()
dt_start_plot <- seq(dt_start_plot, length = 2, by = "-1 year")[2]

# Call the function that creates the plot
plot_gdp_models(
   df.data = df.data,
   df.symbols = df.symbols,
   dfRecession = dfRecession,
   dt.start = dt_start_plot,
   ylim.both = c(-20, 20)
)

if( exists("dt_start_plot")){
  rm(dt_start_plot)
}

```

Look at how the GDP linear fit performed on the test data partition

```{r gdp_lm_resid_calc, echo=FALSE, fig.width = 10, fig.asp = .62}


d.test.resid = (df.test$GDP.Value - predict(list.fit.reg, newdata = df.test))
hist(d.test.resid, main=paste("Residual For", str.symbol, sep=" "))
sd.fit.gdp.m = sd(d.test.resid)

```

Look at a histogram of the residual

```{r gdp_pcr_resid_calc, echo=FALSE, fig.width = 10, fig.asp = .62}

d.test.resid = (df.test$GDP.Value - predict(list.fit.pcr, newdata = df.test))
hist(d.test.resid, main=paste("Residual For", str.symbol.pcr, sep=" "))
sd.fit.gdp.pcr = sd(d.test.resid)

```

```{r gdp_pcr_resid_calc_desc, echo=FALSE, fig.width = 10, fig.asp = .62}

summary(list.fit.pcr)

```

Document the residual as well


```{r gdp_lm_resid_calc_syms, echo=FALSE, fig.width = 10, fig.asp = .62}

str.symbol.res <- "GDP.lm.res"
df.data[str.symbol.res] <- df.data$GDP.Value - df.data$GDP.lm

# Add the GDP linear model prediction residual to the symbols table
df.symbols <- symbols_append_row(
    df.symbols,
    list(
      string.symbol = str.symbol.res,
      string.source = "Predict Resid.",
      string.description = "Residual for \nGDP given INDPRO,PCE, RSALESAGG,\nauto sales, and home sales",
      string.label.y = df.symbols[df.symbols$string.symbol==str.symbol,"string.label.y"],
      float.expense.ratio = -1.00,
      Max030 = FALSE,
      Max180 = FALSE,
      date.series.start = dt_start_prediction_gdp,
      date.series.end = as.Date(Sys.Date()),
      string.symbol_safe = safe_symbol_name(str.symbolYoY),
      string.object_name = safe_symbol_name(str.symbolYoY)
  )
)

# Clean and tidy memory  
if( exists("str.symbol.res")){
  rm(str.symbol.res)
}

```

Document the PCR residual


```{r gdp_pcr_resid_calc_syms, echo=FALSE, fig.width = 10, fig.asp = .62}


str.symbol.pcr.res <- "GDP.pcr.res"
df.data[str.symbol.pcr.res] <- df.data$GDP.Value - df.data$GDP.pcr

# Add the GDP linear model prediction residual to the symbols table

df.symbols <- symbols_append_row(
    df.symbols,
    list(
      string.symbol = str.symbol.pcr.res,
      string.source = "Predict Resid.",
      string.description = "PCR Residual for \nGDP given INDPRO,\nPCE, and RSALESAGG",
      string.label.y = getPlotYLabel(df.symbols, "GDP"),
      float.expense.ratio = -1.00,
      Max030 = FALSE,
      Max180 = FALSE,
      date.series.start = dt_start_prediction_gdp,
      date.series.end = as.Date(Sys.Date()),
      string.symbol_safe = safe_symbol_name(str.symbolYoY),
      string.object_name = safe_symbol_name(str.symbolYoY)
  )
)

# Clean and tidy memory  
if( exists("str.symbol.pcr.res")){
  rm(str.symbol.pcr.res)
}

```


Plot the residual GDP to the linear fit prediction. 

The residuals decrease quite a bit during the Covid numbers, at least as of Jun 2020. Probably indicates uncertainty in the numbers.

```{r gdp_lm_resid_calc_plot, echo=FALSE, fig.width = 10, fig.asp = .62}

str.symbol.res <- "GDP.lm.res"
ylim <- c(-2000, 2000)
myPlot <- plotSingle(
  dfRecession,
  df.data,
  "date",
  datay = str.symbol.res,
  getPlotTitle(df.symbols, str.symbol.res),
  "Date",
  getPlotYLabel(df.symbols, str.symbol.res),
  c(as.Date("1jan1967", "%d%b%Y"), Sys.Date()),
  ylim,
  b.legend = TRUE,
  b.percentile = TRUE,
  b.long.legend = FALSE
)

myPlot <- myPlot + geom_hline(yintercept=(6*sd.fit.gdp.m), color = "red", linetype="dashed")
myPlot <- myPlot + geom_hline(yintercept=(-6*sd.fit.gdp.m), color = "red", linetype="dashed")

print(myPlot)

# Clean and tidy memory  
if( exists("str.symbol.res")){
  rm(str.symbol.res)
}

if( exists("myPlot")){
  rm(myPlot)
}

```

Plot the residual GDP to the PCR fit prediction. 

The residuals decrease quite a bit during the Covid numbers, at least as of Jun
2020. Probably indicates uncertainty in the numbers.

```{r gdp_pcr_resid_calc_plot, echo=FALSE, fig.width = 10, fig.asp = .62}

str.symbol <- "GDP.pcr.res"
ylim <- c(-9000, 9000)
myPlot <- plotSingle(
  dfRecession,
  df.data,
  "date",
  datay = str.symbol,
  getPlotTitle(df.symbols, str.symbol),
  "Date",
  getPlotYLabel(df.symbols, str.symbol),
  c(as.Date("1jan1967", "%d%b%Y"), Sys.Date()),
  ylim,
  b.legend = TRUE,
  b.percentile = TRUE,
  b.long.legend = FALSE
)

myPlot <- myPlot + geom_hline(yintercept=(6*sd.fit.gdp.pcr), color = "red", linetype="dashed")
myPlot <- myPlot + geom_hline(yintercept=(-6*sd.fit.gdp.pcr), color = "red", linetype="dashed")

print(myPlot)

# Clean and tidy memory  
if( exists("str.symbol.res")){
  rm(str.symbol.res)
}

if( exists("myPlot")){
  rm(myPlot)
}

```




