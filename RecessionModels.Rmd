---
title: "RecessionModels"
author: "Brian Howard"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output: 
  html_document:
    toc: true
    toc_depth: 4
    smart: false
output_file: "RecessionModels.html"    
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, echo=FALSE}

knitr::opts_chunk$set(echo = TRUE)
options("getSymbols.warning4.0"=FALSE)

```

```{r libraries, echo=FALSE, message=FALSE}

library(tidyverse)
library(tidyquant)
library(Hmisc)
library(gridExtra)
library(signal)
library(caret)
library(data.table)
library(lubridate)
#install.packages("NeuralNetTools")
library(NeuralNetTools)

```

```{r helper functions, echo=FALSE}

# Call helper functions
source("plotHelper.r")
source("modelHelper.r")

```

```{r load.data, echo=FALSE}

str.data.dir <- "C:/Users/Rainy/OneDrive/Documents/IssaquahDynamical/Datasets/2529RS0082_HistEconData"
out.file <- file.path(str.data.dir, "RecessionIndicator_Buffer.RData")

# Load data
load(out.file)

rm(out.file)

```

```{r plot.limits, echo=FALSE}

# Define the plotting ranges
dt.recent = as.Date("2017-01-01")

# Define the start of the prediction
dt.start.prediction <- as.Date("01/02/1962", "%d/%m/%Y")

# Back test range
dt_start_back_test = as.Date('1960-01-01')

# Define the S&P 500 limits
source("SetGSPCMax.r")

```

```{r clean_data, echo=FALSE}

# Keep only the symbols needed by this code
df.symbols <- dplyr::filter(df.symbols,
                            string.symbol %in% c("USREC",
                                                 "GDP",
                                                 "GDPC1",
                                                 "CPROFIT",
                                                 "RecInit",
                                                 "^GSPC",
                                                 "GDPDEF",
                                                 "DGS10",
                                                 "TB3MS",
                                                 "UNRATE",
                                                 "ICSA",
                                                 "W875RX1",
                                                 "HSN1FNSA",
                                                 "CPIAUCSL",
                                                 "POPTHM"))

if( exists("b.refresh.models")){
  rm(b.refresh.models)
}

if( exists("bRefresh")){
  rm(bRefresh)
}

if( exists("d.income")){
  rm(d.income)
}

if( exists("d.Russell.max")){
  rm(d.Russell.max)
}

if( exists("dt.date")){
  rm(dt.date)
}

if( exists("dt.date.c")){
  rm(dt.date.c)
}

if( exists("i.cols")){
  rm(i.cols)
}

if( exists("idx")){
  rm(idx)
}

if( exists("iDays")){
  rm(iDays)
}

if( exists("list.margin.names")){
  rm(list.margin.names)
}

if( exists("list.options.names")){
  rm(list.options.names)
}

if( exists("str.name")){
  rm(str.name)
}

if( exists("str.safe.name")){
  rm(str.safe.name)
}

if( exists("str_symbol")){
  rm(str_symbol)
}

if( exists("str.symbol")){
  rm(str.symbol)
}

if( exists("str_out")){
  rm(str_out)
}

if( exists("str.symbol.raw")){
  rm(str.symbol.raw)
}

if( exists("str_symbol.raw")){
  rm(str_symbol.raw)
}

if( exists("ylimBackTest")){
  rm(ylimBackTest)
}

if( exists("df.farm.income")){
  rm(df.farm.income)
}

```

# Clean and tidy data

## Feature Extraction

With the raw data downloaded, some of the interesting features can be
extracted. The first step is reconcile the time intervals. Some of the
data is released monthly and some daily. I chose to interpolate all data
to a daily interval. The first section of code adds the daily rows to
the data frame.

The code performs interpolation for continuous data or carries it
forward for binary data like the recession indicators.

```{r aggsyms}

source("calcInterpolate.r")
df.data <- calcInterpolate(df.symbols)

```

## Truncate data

```{r data.trunc, echo=FALSE, fig.width = 10, fig.asp = .62}

# A very few data series do go back to 1854, but most
# don't even go past WWII so truncate the data frame.
df.data <- df.data[as.Date(rownames(df.data)) > as.Date("1940-01-01"),]

```

## Create aggregate series

Some analysis requires that two or more series be combined. For example,
normallizing debt by GDP to get a sense of the proportion of debt to the
total economy helps understand the debt cycle.

```{r create aggregate, echo=FALSE}

source("calcAggregateSeries.r")

```

Year over year, smoothed derivative, and log trends tend to smooth out
seasonal variation. It gets used so often that I do this for every
series downloaded.

```{r calcsYoYSmoothLog}

source("calcFeatures.r")
lst.df <- calcFeatures(df.data, df.symbols)
df.data <- lst.df[[1]]
df.symbols <- lst.df[[2]]

```

```{r calc.features.for.aggregate, echo=FALSE}

# Calculate the features for the aggregated series
source("calcFeaturesAggregate.r")

```

# Recession initiation and termination dates/times

Build the recession and recession initiation dates

```{r recframe}

source("calcRecession.r")

```

# Recession models

## Input data series

The labor market is one of the clearest, most reliable signals of broad
economic turning pointsâ€”but it lags.

```{r rec_model_unrate_base, echo=FALSE, fig.width = 10, fig.asp = .62}

# Define the symbols in the plot
lst_syms <- c("UNRATE.Value", "UNRATE.Value__Smooth")

if (require_columns(df.data, lst_syms)) {

  myPlot <- plotSingle(
    dfRecession,
    df.data,
    "date",
    datay = lst_syms[[1]],
    getPlotTitle(df.symbols, lst_syms[[1]]),
    "Date",
    getPlotYLabel(df.symbols, lst_syms[[1]]),
    c(as.Date("1jan1950", "%d%b%Y"), Sys.Date()),
    ylim = c(2, 12),
    b.legend = TRUE,
    b.percentile = TRUE
  )
  
  myPlot + geom_line(
    data = df.data,
    aes(
      x = .data[["date"]],
      y = .data[[lst_syms[[2]]]],
      colour = getPlotYLabel(df.symbols, lst_syms[[2]])
    ),
    na.rm = TRUE
  )
}

```

```{r rec_model_GDP_base, echo=FALSE, fig.width = 10, fig.asp = .62}

# Define the symbols in the plot
lst_syms <- c("GDP.Value")

# Do they exist in the data frame?
if ( require_columns(df.data, lst_syms ) ){

  my_plot <-
    plotSingle(
      dfRecession,
      df.data,
      "date",
      datay = lst_syms[[1]],
      getPlotTitle(df.symbols, lst_syms[[1]]),
      "Date",
      getPlotYLabel(df.symbols, lst_syms[[1]]),
      c(dt.start.prediction, Sys.Date()),
      ylim = c(1, round_up_to(max(df.data[[lst_syms[[1]]]]),5000)),
      b.legend = TRUE,
      b.percentile = FALSE,
      b.long.legend = TRUE
    )

  print(my_plot)
  
  # Free up memory
  if( exists("my_plot")){
    rm(my_plot)
  }
}


# Free up memory
if( exists("lst_syms")){
  rm(lst_syms)
}


```

```{r rec_model_cprofit_by_gdp_base, echo=FALSE, fig.width = 10, fig.asp = .62}

# Define the symbols in the plot
lst_syms <- c("CPROFIT__by__GDP")

# Do they exist in the data frame?
if ( require_columns(df.data, lst_syms ) ){

  my_plot <-
    plotSingle(
      dfRecession,
      df.data,
      "date",
      datay = lst_syms[[1]],
      getPlotTitle(df.symbols, lst_syms[[1]]),
      "Date",
      getPlotYLabel(df.symbols, lst_syms[[1]]),
      c(dt.start.prediction, Sys.Date()),
      ylim = c(5, round_up_to(max(df.data[[lst_syms[[1]]]]),5)),
      b.legend = TRUE,
      b.percentile = FALSE,
      b.long.legend = TRUE
    )

  print(my_plot)
  
  # Free up memory
  if( exists("my_plot")){
    rm(my_plot)
  }
}


# Free up memory
if( exists("lst_syms")){
  rm(lst_syms)
}


```

## Recession Initiation (Switch Model)

Plot the initiation period of each recession, defined retroactively by
the NEBR, using a state of 0 or 1.

```{r rec_model_rec_init_switch, echo=FALSE, fig.width = 10, fig.asp = .62}

# Define the symbols in the plot
lst_syms <- c("RecInit")

# Do they exist in the data frame?
if ( require_columns(df.data, lst_syms ) ){

  my_plot <-
    plotSingle(
      dfRecession,
      df.data,
      "date",
      datay = lst_syms[[1]],
      getPlotTitle(df.symbols, lst_syms[[1]]),
      "Date",
      getPlotYLabel(df.symbols, lst_syms[[1]]),
      c(dt.start.prediction, Sys.Date()),
      ylim = c(-0.1, 1.1),
      b.legend = TRUE,
      b.percentile = FALSE,
      b.long.legend = TRUE
    )

  print(my_plot)
  
  # Free up memory
  if( exists("my_plot")){
    rm(my_plot)
  }
}


# Free up memory
if( exists("lst_syms")){
  rm(lst_syms)
}


```

## Recession Initiation (Smooth Model)

The previous section used a switched model (Yes/No), but this section
uses a smoothed version that is more like a probability value.

Plot the smoothed version of the initiation period of the recession
initiation.

```{r rec_model_rec_init_smooth, echo=FALSE, fig.width = 10, fig.asp = .62}

# Define the symbols in the plot
lst_syms <- c("RecInit_Smooth")

# Do they exist in the data frame?
if ( require_columns(df.data, lst_syms ) ){

  my_plot <-
    plotSingle(
      dfRecession,
      df.data,
      "date",
      datay = lst_syms[[1]],
      getPlotTitle(df.symbols, lst_syms[[1]]),
      "Date",
      getPlotYLabel(df.symbols, lst_syms[[1]]),
      c(dt.start.prediction, Sys.Date()),
      ylim = c(-0.1, 1.1),
      b.legend = TRUE,
      b.percentile = FALSE,
      b.long.legend = TRUE
    )

  print(my_plot)
  
  # Free up memory
  if( exists("my_plot")){
    rm(my_plot)
  }
}


# Free up memory
if( exists("lst_syms")){
  rm(lst_syms)
}


```

# Data Exploration

There are some great plotting and visualization tools in the `quantmod` package,
but for the prediction work `ggplot` will be used. This section walks through
each of the data sets and notes features and relationships that would be helpful
in building a trading strategy.

## S&P 500

One place to begin is with the relationship between stock prices and recessions.
The predictor needs to be able to identify the onset of recession before the
market declines. In theory, this predictor would give enough warning to cycle
out of equity and into something more like cash or bonds. The plot below shows
the S&P 500 open values in log-linear format. The market reaches a peak before
most recessions, typically 6-9 months before the recession, shown by the blue
rectangles in the plot below. A good predictor will correlate with the peak
prior to an upcoming recession.

The growth of equities makes it hard to compare peaks. For example, using the
GDP deflator the last two decades are an order of magnitude higher than the
historical data.

```{r rec_model_data_exp_GSPC_by_GPDEF, echo=FALSE, fig.width = 10, fig.asp = .62}

# Define the symbols in the plot
lst_syms <- c("X_GSPC__Open__by__GDPDEF", "X_GSPC__Close__by__GDPDEF")

# Do they exist in the data frame?
if ( require_columns(df.data, lst_syms ) ){

  my_plot <-
    plotSingle(
      dfRecession,
      df.data,
      "date",
      datay = lst_syms[[1]],
      getPlotTitle(df.symbols, lst_syms[[1]]),
      "Date",
      getPlotYLabel(df.symbols, lst_syms[[1]]),
      c(dt.start.prediction, Sys.Date()),
      ylim = c(0.0, round_up_to(max(df.data[[lst_syms[[1]]]]),5)),
      b.legend = TRUE,
      b.percentile = FALSE,
      b.long.legend = TRUE
    )

  my_plot <- my_plot + geom_line(
    data = df.data,
    aes(
      x = .data[["date"]],
      y = .data[[lst_syms[[2]]]],
      colour = getPlotTitle(df.symbols, lst_syms[[2]])
    ),
    
    na.rm = TRUE
  )
  print(my_plot)
  
  # Free up memory
  if( exists("my_plot")){
    rm(my_plot)
  }
}


# Free up memory
if( exists("lst_syms")){
  rm(lst_syms)
}


```
Taking the log of the data results in a series where the peaks in the historical data can be seen and compared to present day pricing.

```{r rec_model_data_exp_GSPC_by_GPDEF_log, echo=FALSE, fig.width = 10, fig.asp = .62}

# Define the symbols in the plot
lst_syms <- c("X_GSPC__Open__by__GDPDEF__Log", 
              "X_GSPC__Close__by__GDPDEF__Log")

# Do they exist in the data frame?
if ( require_columns(df.data, lst_syms ) ){

  my_plot <-
    plotSingle(
      dfRecession,
      df.data,
      "date",
      datay = lst_syms[[1]],
      getPlotTitle(df.symbols, lst_syms[[1]]),
      "Date",
      getPlotYLabel(df.symbols, lst_syms[[1]]),
      c(dt.start.prediction, Sys.Date()),
      ylim = c(5, round_up_to(max(df.data[[lst_syms[[1]]]]),1)),
      b.legend = TRUE,
      b.percentile = FALSE,
      b.long.legend = TRUE
    )

  my_plot <- my_plot + geom_line(
    data = df.data,
    aes(
      x = .data[["date"]],
      y = .data[[lst_syms[[2]]]],
      colour = getPlotTitle(df.symbols, lst_syms[[2]])
    ),
    
    na.rm = TRUE
  )
  print(my_plot)
  
  # Free up memory
  if( exists("my_plot")){
    rm(my_plot)
  }
}


# Free up memory
if( exists("lst_syms")){
  rm(lst_syms)
}


```
The features in the S&P curve that are most interesting are the peaks (sell signal) and the troughs (buy signal). One way to quantify the peaks is look at the derivative and see where it crosses zero. The crossing of interest are positive to negative indicating the market is rolling over. Most of the peaks occur just prior to or during the blue intervals used for training.

```{r rec_model_data_exp_GSPC_by_GPDEF_log_smooth_der, echo=FALSE, fig.width = 10, fig.asp = .62}

# Define the symbols in the plot
lst_syms <- c("X_GSPC__Open__by__GDPDEF__SmoothDer", 
              "X_GSPC__Close__by__GDPDEF__SmoothDer")

# Do they exist in the data frame?
if ( require_columns(df.data, lst_syms ) ){

  my_plot <-
    plotSingle(
      dfRecession,
      df.data,
      "date",
      datay = lst_syms[[1]],
      getPlotTitle(df.symbols, lst_syms[[1]]),
      "Date",
      getPlotYLabel(df.symbols, lst_syms[[1]]),
      c(dt.start.prediction, Sys.Date()),
      ylim = c(-round_up_to(max(df.data[[lst_syms[[1]]]]),1), 
               +round_up_to(max(df.data[[lst_syms[[1]]]]),1)),
      b.legend = TRUE,
      b.percentile = FALSE,
      b.long.legend = TRUE
    )

  my_plot <- my_plot + geom_line(
    data = df.data,
    aes(
      x = .data[["date"]],
      y = .data[[lst_syms[[2]]]],
      colour = getPlotTitle(df.symbols, lst_syms[[2]])
    ),
    
    na.rm = TRUE
  )
  print(my_plot)
  
  # Free up memory
  if( exists("my_plot")){
    rm(my_plot)
  }
}


# Free up memory
if( exists("lst_syms")){
  rm(lst_syms)
}


```

## Synthesize S&P 500 recession initiation feature

The derivative data suggests a way to improve the indicator by adding a single
rule: if there is a negative slope zero crossing before the default training
period, move the training date to that point. This approach will allow the
algorithm to capture more of the gains of the market. It is also going to be a
more challenging fit.

```{r rec_model_data_exp_GSPC_by_GPDEF_log_smooth_der_fit, echo=FALSE, fig.width = 10, fig.asp = .62}

dPeakGSPC <- diff(sign(df.data$X_GSPC__Open__by__GDPDEF__SmoothDer))
dPeakGSPC <- append(dPeakGSPC, tail(dPeakGSPC,1))
df.data$dPeakGSPC <- dPeakGSPC

if( exists("dPeakGSPC")){
  rm(dPeakGSPC)
}

# keep only the negative slopes and get rid of any dates
# while the fixed recession indicator is zero
df.data$dPeakGSPC[df.data$dPeakGSPC>0] <- 0
df.data$dPeakGSPC <- (df.data$dPeakGSPC * df.data$RecInit)
dtPeakRec <- df.data$date[which(df.data$dPeakGSPC<0)]

dfRecession$initStartMod <- dfRecession$initStart
for (idxRec in 1:nrow(dfRecession)) {
  for (idx in 1:length(dtPeakRec)) {
    if (dtPeakRec[idx] > dfRecession$initStart[idxRec] &
        dtPeakRec[idx] < dfRecession$initEnd[idxRec]) {
      dfRecession$initStartMod[idxRec] <- dtPeakRec[idx]
      
    }
    
  }
}

if( exists("idxRec")){
  rm(idxRec)
}
if( exists("idx")){
  rm(idx)
}
if( exists("dtPeakRec")){
  rm(dtPeakRec)
}

dfRecession$initEndMod <- dfRecession$start + floor((dfRecession$end-dfRecession$start)/2)

# Add the recession initiation date as a time series
df.data$RecInitMod <- rep(0, nrow(df.data))

for (idx in 1:nrow(dfRecession)) {
  df.data$RecInitMod[which(df.data$date > dfRecession$initStartMod[idx] &
                            df.data$date < dfRecession$initEndMod[idx])] = 1
}

df.symbols <- symbols_append_row(
    df.symbols,
    list(
      string.symbol = "RecInitMod",
      string.source = "Calc",
      string.description =  "1 for Recession Initiation Period, 0 For All Else (Modified)",
      string.label.y = "(-)",
      float.expense.ratio = -1.00,
      Max030 = FALSE,
      Max180 = FALSE,
      date.series.start = as.Date(df.data$date[1]),
      date.series.end = as.Date(tail(df.data$date, 1))
    )
)

```

## Plot S&P 500 recession initiation feature

Plot out this modified recession initiation feature

```{r rec_model_data_exp_GSPC_by_GPDEF_log_smooth_der_fit_plot, echo=FALSE, fig.width = 10, fig.asp = .62}

lst_syms <- c("RecInitMod")

if (require_columns(df.data, lst_syms)) {
  
  myPlot <- plotSingle(
    dfRecession,
    df.data,
    "date",
    datay = lst_syms[[1]],
    getPlotTitle(df.symbols, lst_syms[[1]]),
    "Date",
    getPlotYLabel(df.symbols, lst_syms[[1]]),
    c(as.Date("1jan1945", "%d%b%Y"), Sys.Date()),
    ylim = c(0.00, 1.00),
    FALSE
  )
  myPlot + geom_rect(
    data = dfRecession,
    aes(
      xmin = initStartMod,
      xmax = initEndMod,
      ymin = -Inf,
      ymax = Inf
    ),
    fill = "green",
    alpha = 0.25,
    na.rm = TRUE
  )
  

  
  
}

if( exists("lst_syms")){
  rm(lst_syms)
}

```
## Plot S&P 500 trends and initiation feature

Finally, overlay the S&P 500 trends to see how using the decline in the S&P 500
helped move the initiator. In most cases the new initiator (green) has moved to
the left, providing and early indication of recession. It is interesting that
the market declines often preceed the calls of recession by the NEBR.

```{r rec_model_data_exp_GSPC_by_GPDEF_log_smooth_der_fit_plot2, echo=FALSE, fig.width = 10, fig.asp = .62}

lst_syms <- c("X_GSPC__Open__by__GDPDEF__SmoothDer")

if (require_columns(df.data, lst_syms)) {
  
  myPlot <- plotSingle(
    dfRecession,
    df.data,
    "date",
    datay = lst_syms[[1]],
    getPlotTitle(df.symbols, lst_syms[[1]]),
    "Date",
    getPlotYLabel(df.symbols, lst_syms[[1]]),
    c(as.Date("1jan1945", "%d%b%Y"), Sys.Date()),
    ylim = c(-5.0, 5.0 ),
    FALSE
  )
  myPlot + geom_rect(
    data = dfRecession,
    aes(
      xmin = initStartMod,
      xmax = initEndMod,
      ymin = -Inf,
      ymax = Inf
    ),
    fill = "green",
    alpha = 0.25,
    na.rm = TRUE
  )
  

  
  
}

if( exists("lst_syms")){
  rm(lst_syms)
}

```

Take a look at year-over-year as related to the recessions

```{r rec_model_SP500_YoY, echo=FALSE, fig.width = 10, fig.asp = .62}

lst_syms <- c("X_GSPC.GSPC.Open__YoY")

if (require_columns(df.data, lst_syms)) {

  plotSingleQuick(
    dfRecession,
    df.data,
    datay = lst_syms[[1]],
    ylim = c(-55, 55),
    dt.start = as.Date("1jan1950", "%d%b%Y") ,
    b.percentile = TRUE
  )
  
}

if (exists("lst_syms")) {
  rm(lst_syms)
}

```
## GDP Derivative

This series tends to dip prior to a recession. Derivatives are noisy so I do not
expect it to be a strong predictor, but I think it is worth considering.

```{r GDPBYCPIAUCSLBYPOPTHM_SmoothDer, echo=FALSE}

lst_syms <- c("GDPBYCPIAUCSLBYPOPTHM__SmoothDer")
if ( require_columns(df.data, lst_syms ) ){
  
  plotSingleQuick(dfRecession, 
                  df.data, 
                  datay = lst_syms[[1]],
                  ylim = c(-5, 5), 
                  dt.start = as.Date('1960-01-01'), 
                  b.percentile = TRUE)

}

# Clean and tidy memory  
if( exists("lst_syms")){
  rm(lst_syms)
}

```

# Prior art

There are some models out there with claims to predict recessions. This section
summarizes some of those.

## New York Federal Reserve

I really like this for the simplicity; however, it is recently not the best
predictor. Refer to the website
https://www.newyorkfed.org/research/capital_markets/ycfaq.html for details. 

I had to read through the reference papers to understand how the alpha and beta
factors were used.

The fed shifts their data so the predictor aligns with the recessions; however I
wanted the predictor to appear before the recessions so I do not shift it.

```{r rec_model_ny_fed, echo=FALSE, fig.width = 10, fig.asp = .62}

# Save this one off to a vector-based .pdf
str_pdf_path = paste(str.data.dir, "/Fed_Model",".pdf",sep="")
pdf(file = str_pdf_path,  width = 8, height = 6, , useDingbats = FALSE)   

# Create the plot, if the data series exists
lst_syms <- c("nyfed.recession")

if (require_columns(df.data, lst_syms)) {
  
  my_plot <- plotSingleQuick(dfRecession,
                            df.data,
                            datay = lst_syms[[1]],
                            ylim = c(-0.1, 1.1))
  print(my_plot)

  # Close the device to finalize the file
  dev.off()
  
  # Free up memory
  if (exists("my_plot")) {
    rm(my_plot)
  }

}

# Free up memory
if (exists("lst_syms")) {
  rm(lst_syms)
}

```

# Machine learning

## Select data features and date range for training, testing, and validation

```{r rec_model_features, echo=TRUE, fig.width = 10, fig.asp = .62}

# Define symbols to be used in the study
lst_syms <- c("DGS10TOTB3MS", "UNRATE.Value", "W875RX1.Value__YoY",
              "ICSA.Value__YoY","GDPBYCPIAUCSLBYPOPTHM__SmoothDer",
              "HSN1FNSA.Value__YoY")

model.features <- list(
  c(lst_syms[[1]]),
  c(
    lst_syms[[1]],
    lst_syms[[2]]
    ),
  c(
    lst_syms[[1]],
    lst_syms[[3]]
    ),
  c(
    lst_syms[[1]],
    lst_syms[[4]]
    ),
  c(
    lst_syms[[1]],
    lst_syms[[5]]
    ),
  c(
    lst_syms[[1]],
    lst_syms[[6]]
    ),
  c(
    lst_syms[[1]],
    lst_syms[[2]],
    lst_syms[[3]]
    ),
  c(
    lst_syms[[1]],
    lst_syms[[2]],
    lst_syms[[4]]
    ),
  c(
    lst_syms[[1]],
    lst_syms[[3]],
    lst_syms[[4]]
    ),
  c(
    lst_syms[[1]],
    lst_syms[[3]],
    lst_syms[[4]],
    lst_syms[[5]]
  ),
  c(
    lst_syms[[1]],
    lst_syms[[2]],
    lst_syms[[3]],
    lst_syms[[4]]
    ),
  c(
    lst_syms[[1]],
    lst_syms[[2]],
    lst_syms[[3]],
    lst_syms[[4]],
    lst_syms[[6]]
  ),
  c(
    lst_syms[[1]],
    lst_syms[[2]],
    lst_syms[[3]],
    lst_syms[[4]]),
  c(
    lst_syms[[1]],
    lst_syms[[2]],
    lst_syms[[3]],
    lst_syms[[4]],
    lst_syms[[5]]
  ),
  c(
    lst_syms[[1]],
    lst_syms[[2]],
    lst_syms[[3]],
    lst_syms[[4]],
    lst_syms[[5]],
    lst_syms[[6]]
  )
)

# Save off the number of feature series
i.model.count <- length(model.features)

```


## Select date range for training, testing, and validation

The data series have different start dates and they are not updated at the same
time. This bit of code selects a valid data range to develop the model.

```{r rec_model_date_twiddling, echo=TRUE, fig.width = 10, fig.asp = .62}


# Pick the most recent data sample. TODO: this is done manually, but needs to be automated
#dt.start.prediction <- index(get(model.features[1])[1])
dt.start.prediction <- as.Date("01/02/1962", "%d/%m/%Y")

# If the series was downloaded as a zoo object, check that the start date is valid
for (strSeries in model.features[-1]){
  result = tryCatch({
    dtThis <- index(get(strSeries)[1])
    if( dtThis > dt.start.prediction){
      dtStart <- dtThis
    }
  }, error = function(e){
    # do nothing for now...TO DO: adjust dates.
  })
}

dt.end.prediction <- as.Date("2018-06-30")
df.dataModel <-
  df.data[df.data$date >= dt.start.prediction &
            df.data$date <= dt.end.prediction, ]
str.training.date.range <-
  paste("Training Date Range: ",
        dt.start.prediction,
        " to ",
        dt.end.prediction,
        sep = "")
print(str.training.date.range)

```
